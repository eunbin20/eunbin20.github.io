---
title: Controlled Component vs Uncontrolled Component
date: 2022-06-11 00:00
modified: 2022-06-11 00:00
tags: [react, react-hook-form, controlled-component-vs-uncontrolled-component]
description: react-hook-form은 uncontrolled component를 베이스로 form을 핸들링하는 라이브러리로 최소한의 리렌더링을 통한 높은 성능을 제공한다.
image: https://user-images.githubusercontent.com/43979066/175811355-320d6fe8-b8c1-46b3-8fe6-02491fe76495.png
---

- [Controlled Component(제어 컴포넌트)](#controlled-component제어-컴포넌트)
- [Uncontrolled Component(비제어 컴포넌트)](#uncontrolled-component비제어-컴포넌트)
  - [두 방식의 차이점](#두-방식의-차이점)
      - [왜 React에는 이 두 가지 방식이 모두 존재하는걸까?](#왜-react에는-이-두-가지-방식이-모두-존재하는걸까)
  - [언제 제어 컴포넌트를 사용해야 할까](#언제-제어-컴포넌트를-사용해야-할까)
- [_Resources_](#resources)

# Controlled Component(제어 컴포넌트)

> [공식문서](https://ko.reactjs.org/docs/forms.html#controlled-components)에 따르면 제어 컴포넌트의 정의는 다음과 같다.
> 제어 컴포넌트는 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트합니다. React에서는 변경할 수 있는 state가 일반적으로 컴포넌트의 state 속성에 유지되며 setState()에 의해 업데이트됩니다.

즉 제어 컴포넌트는 form 요소를 렌더링하는 컴포넌트에서 **form 요소의 입력값을 DOM이 아닌 리액트 컴포넌트가 "제어(control)"**하는 컴포넌트를 의미한다. 제어 컴포넌트는 기본적인 HTML form 요소의 동작을 재정의한다.

<figure>
  <img src="https://user-images.githubusercontent.com/43979066/175813994-2ccc6d97-80a4-4e94-a214-1190da576c2f.png" alt="controlled component image" width=500>
</figure>

다음 코드는 제어 컴포넌트로 구현된 폼 요소의 예시 코드이다.

```jsx
const { useState } from 'react';

function Controlled () {
  const [email, setEmail] = useState();

  const handleInput = (e) => setEmail(e.target.value);

  return <input id="email" type="text" value={email} onChange={handleInput} />;
}
```

1. email input이 가진 `value`속성이 `email`이라는 상태와 연결되어있다. 이는 컴포넌트의 state와 input의 입력값이 항상 동기화된다는 것을 뜻한다.
2. email input에서 change event가 발생하면 `handleInput`콜백함수가 트리거되고 이 콜백함수 안에서는 입력값이 업데이트될 때마다 `email` state를 업데이트한다.

email input 요소의 입력값이 바뀔 때마다 `onChange`이벤트가 발생하고, 바뀐 값들은 `useState()`함수에 의해 업데이트되어 사용자에게 보여진다. 즉, 사용자의 입력값이 바뀔 때마다 리렌더링이 일어나게 된다.

이렇게 데이터가 변경될 수 있는 모든 방법에 대해 이벤트 핸들러를 작성하고 `useState()`를 통해 모든 입력 값의 state를 form 요소와 연결해야하기 때문에 제어컴포넌트를 사용하는 방법은 로직이 길어지게 된다.

게다가 내가 구현해야했던 회원가입 폼 같은 경우 여러 개의 유효성 검사 규칙이 있었고 그 각각에 대한 처리 결과들도 state로 관리해야했다.

이렇게 긴 코드와 비효율적인 리렌더링 문제를 해결하기 위한 대안으로 비제어 컴포넌트를 이용할 수 있다.

# Uncontrolled Component(비제어 컴포넌트)

비제어 컴포넌트를 이용한 방식은 입력값을 실시간으로 업데이트하지 않는다.

그렇다면 비제어 컴포넌트의 경우 사용자가 input 요소에 입력한 입력값을 어떻게 가져올까?

> [공식문서](https://ko.reactjs.org/docs/uncontrolled-components.html)에서는 다음과 같이 비제어 컴포넌트를 설명하고 있다.
> 모든 state 업데이트에 대한 이벤트 핸들러를 작성하는 대신 비제어 컴포넌트를 만들려면 ref를 사용하여 DOM에서 폼 값을 가져올 수 있습니다.
> 비제어 컴포넌트는 DOM에 신뢰 가능한 출처를 유지하므로 비제어 컴포넌트를 사용할 때 React와 non-React 코드를 통합하는 것이 쉬울 수 있습니다. 빠르고 간편하게 적은 코드를 작성할 수 있지만, 그 외에는 일반적으로 제어된 컴포넌트를 사용해야 합니다.

바로 [Refs](https://reactjs.org/docs/refs-and-the-dom.html)를 이용한다. Ref는 리액트에서 DOM 요소를 참조하기 위해 사용되는 방식이다.

<figure>
  <img src="https://user-images.githubusercontent.com/43979066/175814525-c73a97c6-5d1d-4bfd-9b68-174327a531b5.png" alt="controlled component image" width=500>
</figure>

다음 코드는 비제어 컴포넌트로 구현된 폼 요소의 예시 코드이다.

```jsx
const { useState } from 'react';

function Controlled () {
  const emailRef = useRef();

  return <input id="email" type="text" ref={emailRef} />;
}
```

`emailRef`를 만들어 email input요소에 접근했다. 한 눈에 봐도 로직이 간결해졌음을 알 수 있다.

이 방식에서는 form을 제출할 때 `emailRef.current.value`로 해당 input 요소의 입력값에 접근할 수 있을 것이다.

입력값이 변경될 때마다 state를 업데이트하거나 유효성 검사 규칙을 처리해 사용자가 입력한 값과 state를 동기화해야할 필요가 없는 경우 비제어 컴포넌트를 활용하면 코드를 많이 줄일 수 있을 것이다.

## 두 방식의 차이점

- 제어컴포넌트에서 form 데이터는 React component에 의해 제어된다. 비제어컴포넌트는 DOM 요소 자체에서 그 데이터를 제어한다.
- 제어컴포넌트 사용자의 입력값이 실시간으로 **동기화**된다. 그러나 비제어컴포넌트에서는 직접 트리거하지 않는 이상 리렌더링이 발생하지도 않고 실시간으로 값이 동기화되지 않는다.

#### 왜 React에는 이 두 가지 방식이 모두 존재하는걸까?

다른 MVC 패턴의 프레임워크들과 달리, React는 "View Library"에 좀 더 치우친 라이브러리이다. 그래서 리액트는 Model-View 방식으로 접근하는 제어 컴포넌트와 View만을 이용한 방식으로 접근하는 비제어 컴포넌트를 모두를 유연하게 제공하는 것이다. form을 구현하려는 상황에 맞게 적절한 방식을 선택하여 사용하면 될 것 같은데, 다만 React의 공식적인 입장은 제어 컴포넌트를 더 권장하고있다.

나는 더 명시적이고 간결한 로직으로, 효율적인 리렌더링으로

## 언제 제어 컴포넌트를 사용해야 할까

- 유효성 검사
- 사용자의 입력을 제한하는 경우(ex. 특정 문자열의 입력을 제한, 특정 길이 이내로 입력을 제한)
- 사용자가 입력한 값을 즉시 포매팅해야하는 경우(ex. 전화번호, 신용카드번호 입력, 숫자에 단위 표시)

위와 같은 상황에서는 제어 컴포넌트를 사용해야 한다. 그래서 나도 제어 컴포넌트를 사용해 회원가입 폼을 구현했다. 그러나 다음과 같은 문제점이 발생했다.

1. 로직이 너무 길고 복잡하다. 위에서 설명했던 것 처럼 제어컴포넌트는 리액트의 컴포넌트단에서 이벤트 핸들러와 state로 입력값을 제어해야 하고 유효성 검사 규칙이 많아짐에 따라 각각의 인풋에 대한 유효성 검사 처리 결과도 state로 관리해주어야 해서 코드가 복잡하고 가독성이 낮아졌다.
2. 제어컴포넌트의 경우 회원가입 폼 내에 있는 모든 input 요소의 값이 변할 때마다 리렌더링이 발생하여 비효율적인 리렌더링이 일어난다.(이를 해결하기 위해 debouce나 throttle 등의 메소드를 사용하였지만 이 역시 코드를 복잡하게 만드는 요인이 되었다.)

하지만 [React Hook Form](https://react-hook-form.com/)이라는 라이브러리를 사용하면 비제어 컴포넌트를 이용해 다양한 경우에서의 유효성 검사를 처리할 수 있고, 제어 컴포넌트가 필요한 경우 특정 인풋 요소에 대해서는 제어컴포넌트로 구현할 수 있다.

그래서 나는 기존 제어 컴포넌트를 이용해 구현했던 회원가입 폼을 React Hook Form을 사용해

# _Resources_

[What are Controlled and Uncontrolled Components in React JS?](https://medium.com/fasal-engineering/controlled-and-uncontrolled-components-in-react-js-c3111ee0a864)
[React: 제어 컴포넌트와 비제어 컴포넌트의 차이점](https://velog.io/@yukyung/React-%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%EB%B9%84%EC%A0%9C%EC%96%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0)
